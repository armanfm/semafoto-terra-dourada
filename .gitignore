
import time
import random
import threading

# Semáforo local simulando o contrato
semaforo = {}
semaforo_lock = threading.Lock()  # trava para evitar condições de corrida

# Provedores
provers = ["prov1", "prov2", "prov3", "prov4"]

# Batches de exemplo
batches = [
    ("batch1_hash", "proof1"),         
    ("batch_errado_hash", "proof2"),   
    ("batch3_hash", "proof3"),         
    ("batch1_hash", "proof1")          
]

# Função para validar batches
def is_batch_valid(batch_hash, proof):
    return batch_hash != "batch_errado_hash"

# Função para enviar batch (agora thread-safe)
def submit_batch_local(prover, batch_hash, proof):
    time.sleep(random.uniform(0.1, 0.5))  # atraso aleatório
    start_time = time.time()

    if not is_batch_valid(batch_hash, proof):
        elapsed = time.time() - start_time
        print(f"Batch {batch_hash} rejeitado por {prover} (inválido) em {elapsed:.3f}s")
        return

    # Lock para evitar conflito de múltiplas threads
    with semaforo_lock:
        if batch_hash not in semaforo:
            semaforo[batch_hash] = prover
            elapsed = time.time() - start_time
            print(f"Batch {batch_hash} aceito por {prover} em {elapsed:.3f}s")
        else:
            elapsed = time.time() - start_time
            print(f"Batch {batch_hash} rejeitado para {prover} (já finalizado por {semaforo[batch_hash]}) em {elapsed:.3f}s")

# Criar threads para simular concorrência
threads = []
for batch_hash, proof in batches:
    for prover in provers:
        t = threading.Thread(target=submit_batch_local, args=(prover, batch_hash, proof))
        threads.append(t)
        t.start()

# Aguardar todas as threads terminarem
for t in threads:
    t.join()

# Resumo final
print("\nResumo do semáforo local:")
for bh, p in semaforo.items():
    print(f"Batch {bh} finalizado por {p}")  
